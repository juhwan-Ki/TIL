최근 소프트웨어를 개발 방법을 획기적으로 뒤집는 두가지 추세가 존재한다 첫 번째는 애플리케이션을 작동시키는 하드웨어와 관련된 것이고 두 번째는 여러 애플리케이션을 합쳐 하나의 애플리케이션으로 만드는 형태인 매시업 형태이다

두 가지 형태 중 매시업 형태에 대해서 유의 깊게 생각해볼 것이다 

만약 여러 애플리케이션을 합쳐서 하나의 서비스를 제공한다고 생각해보자 예를 들어 우리는 영국의 축구 뉴스를 수집하고 번역하여 긍정적인 기사와 부정적인 기사의 수와 분석을 보여주는 애플리케이션을 개발한다고 가정해보자 

1. 영국의 축구 일간지 정보 크롤링
2. 축구 뉴스, 일간지 등의 정보 번역 (구글 번역 API)
3. 통계 및 분석 API (다른 전문 통계 및 분석 API)
4. 화면 보여주기

이러한 형태로 우리의 애플리케이션을 구성할 수 있다 하지만 여기서 중요한 점은 애플리케이션 자체에 국한된 API가 아닌 외부 구글 번역 API, 분석 API 두 가지를 사용했다 이러한 매시업 형태의 애플리케이션을 개발하게 된다면 몇 가지 문제가 발생할 수 있다

- 외부 API의 느린 반응, 응답
- 응답을 기다리는 동안의 자원 낭비
- 외부 API에서 발생하는 오류
- 외부 API와 자체 비즈니스로직의 호환 등

응답을 기다리는 동안의 자원 낭비에 대응 할 수 있는 프로그래밍 방법의 기초 컨셉을 알아보겠다

### 동시성을 구현하는 자바 지원의 진화

자바의 동시 프로그래밍 지원은 지난 20년간 하드웨어, 소프트웨어 시스템, 프로그래밍 컨셉의 큰 변화에 맞춰 진화해왔다 

> 진화 과정
> 
> - 자바 초창기
>     - Runnable과 Thread를 동기화된 클래스와 메소드를 이용
> - 자바 5
>     - ExecutorService 인터페이스를 사용하여 좀 더 표현력있는 동시성을 지원(스레드 실행과 테스크 제출을 분리)
>     - Runnable, Thread의 변형을반환하는 Callable<T>, Future<T> 등을 지원
> - 자바 7
>     - 포크/조인을 구현한 java.util.concurrent.RecursiveTask 지원
> - 자바 8
>     - 람다 지원에 기반한 병렬 프로세싱 추가
>     - Future를 조합하는 기능 추가
> - 자바 9
>     - 분산 비동기 프로그래밍 지원

Future와 분산 비동기 프로그래밍은 앞서 설명한 매시업 애플리케이션을 개발하는데 필수적인(내부를 조금 더 효율적으로 쓰기 위한) 기초 모델과 툴킷을 제공했다 이렇듯 응답을 기다리는 동안의 자원 낭비를 없애기 위한 기본적인 과정을 리액티브 프로그래밍이라 부르며 자바 9에서는 발행-구독 프로토콜(java.util.concurrent.Flow 인터페이스)로 이를 지원했다

<aside>
💡

동시성/병행성 VS 병렬성

동시성 or 병행성(Concurrency)

- 여러가지의 작업을 일부분만 수행하고 다음 작업에 넘어가고를 반복하여 처리
- 다른 작업으로 넘어가야 하기 때문에 Context Switching이 필요
- Context Switching은 매우 빠르게 일어나기 때문에 여러가지 작업을 동시에 수행하는 것 처럼 보이게됨

병렬성(Parallelism)

- 여러 작업이 동시에 처리
- 멀티 코어에서 멀티 스레드를 동작시키는 방식
- 동일한 시간에 독립적인 작업을 실행할 수 있으며 동시성과는 다르게 여러 작업을 
다른 코어, 프로세스 등에 동시에 실행
</aside>

### Executor와 스레드 풀

자바 5는 Executor 프레임워크와 스레드 풀을 통해 스레드의 힘을 높은 수준으로 끌어올리는 즉 프로그래머가 테스크 제출과 실행을 분리할 수 있는 기능을 제공했다

### 스레드의 문제

1. 자바 스레드는 직접 운영체제 스레드에 접근하며 운영체제 스레드를 만들고 종료하려면 비싼 비용(페이지 테이블과 관련한 상호작용)을 치러야 한다
2. 운영체제 스레드 숫자는 제한 되어 있으며 운영체제가 지원하는 스레드 수를 초과해서 사용하면 자바 애플리케이션이 예상치 못한 문제가 발생할 수 있다 
3. 하드웨어에 따라서 스레드를 명시적으로 지정하는 것이 문제의 소지가 생길 수 있다

> 스레드 숫자가 제한되어 있는 이유?
> 
> - 스레드를 무한정 만들게 되면 CPU시간, 메모리 공간 같은 시스템 자원이 고갈되게 된다
>     - 각 스레드는 CPU시간을 나누어서 사용해야 하기 때문에 CPU가 많아지면 성능이 떨어짐
>     - 스레드는 고유한 스택 메모리를 가지기 때문에 스레드가 너무 많으면 메모리가 고갈 될 수 있음
> - Context Switching 오버헤드가 발생한다
>     - Context Switching을 하게 되면 작업 전환에 필요한 정보를 저장하고 복원하는데 시간을 소비하기 때문에 스레드가 많아지면 Context Switching이 빈번하게 발생하여 오버헤드가 증가하고 시스템의 성능이 저하될 수 있음
> - 동기화 문제가 발생한다
>     - 스레드 간의 자원 경쟁이 심해져 동기화 문제가 발생하게 되고 이런 동기화 문제를 해결하기 위해 동기화 메커니즘이 복잡해지고 데드락 같은 문제가 발생할 가능성이 높아짐

### 스레드 풀

자바 ExecutorService는 태스크를 제출하고 나중에 결과를 수집할 수 있는 인터페이스를 제공하며 newFixedThreadPool 같은 팩토리 메소드 중 하나를 이용해 스레드 풀을 만들어 사용할 수 있다

쓰레드 풀이란 쓰레드를 미리 생성하고, 작업 요청이 발생할 때 마다 미리 생성된 쓰레드로 해당 작업을 처리하는 방식을 의미한다 이때 작업이 끝난 쓰레드는 종료되지 않으며 다음 작업 요청이 들어올 때까지 대기한다

스레드 풀 장점

1. 새 스레드를 만들어 주는것이 아닌 기존 스레드를 사용하므로 더 빠르다
2. 스레드를 생성하고 종료하는 오버헤드를 줄일 수 있다
3. 스레드의 갯수를 제한하여 동시에 처리할 수 있는 작업의 갯수를 제한할 수 있다 
    - 스레드 풀의 크기를 조절하여 과도한 작업 요청에 대한 성능 저하를 방지함
4. 다수의 요청을 빠르게 처리할 수 있다

스레드 풀 단점

1. 스레드를 많이 만들게 되면 메모리 낭비가 심하게 될 수 있다

> 스레드 풀 사용 시 주의 사항
> 
> 1. 스레드가 잠자거나 I/O를 기다리거나 네트워크 연결을 기다리는 테스크는 주의해야 한다
>     - 잠자거나 I/O를 기다리거나 하게 되면 해당 태스크는 스레드에 할당 되었지만 실질적으로 작업은 이루어지지 않는 상태
>     - 이렇게 되면 스레드 풀에 남은 스레드 들로 실행이 되어야 하기 때문에 효율이 떨어지게 되며 심한 경우 데드락이 발생할 수 있음
>     - 이런 태스크는 스레드 풀에 제출하지 않는 것이 좋음(하지만 이를 항상 지킬 수 있는 건 아님)
> 2. 스레드를 사용하면 종료하는 습관을 들여야한다 
>     - 자바는 중요 코드를 실행하는 스레드가 죽는 것을 방지하기 위해 main이 반환하기 전에 모든 스레드의 작업을 기다림
>     - 이렇기 때문에 사용이 완료된 스레드는 종료하는 습관을 들여야함
>     - 장기간 실행하는 스레드는 Thread.setDaemon으로 실행하여 프로그램이 종료될 때 같이 종료되록 함(main이 리턴될 때 같이 종료되도록)

<aside>
💡

데몬 스레드란?
데몬 스레드는 백그라운드에서 동작하며 주로 서비스 스레드의 보조 역할을 수행하거나 특정 작업을 주기적으로 처리하는 목적으로 사용됨

데몬 스레드는 프로그램이 종료될 때(메인 스레드가 종료되면) 자동으로 종료되어 명시적으로 종료하지 않아도됨

</aside>

### 스레드로 무엇을 바라는가?

모든 하드웨어 스레드를 활용해 병렬성의 장점을 극대화하도록 프로그램 구조를 만드는 것 즉 프로그램을 작은 태스크 단위로 구조화하는 것이 목표이다

### 동기 API와 비동기 API

아래와 같은 코드를 실행한다고 가정해보자 
아래와 같이 메소드를 실행하게 되면 동기적으로 하나의 메소드가 처리될 때 까지 다음 작업을 실행하지 않고 대기하게 된다 이러한 작업을 비동기적으로 변경해본다

```java
int f(int x); // 매우 오래걸리는 작업 1
int g(int x); // 매우 오래걸리는 작업 2 
...
int y = f(x);
int z = g(x);
System.out.println(y + z);
```

### Runnable을 활용한 코드

```java
class ThreadRunnableExample{ 
	public static void main(String[] args){
		int x = 1337;
		
		Result result = new Result();
		Thread t1 = new Thread(() -> {result.left = f(x)});
		Thread t2 = new Thread(() -> {result.right = g(x)});
		
		t1.start();
		t2.start();
		try {
			t1.join(); // 특정 스레드가 종료될 때까지 현재 스레드를 대기 상태로 만듬
			t2.join();
		} catch (InterruptedException e) {
        e.printStackTrace();
    }
		System.out.println(result.left + result.right);
	}
	
	private static class Result{
		private int left;
		private int right;
	}
}
/*
	단점
	 - 코드가 복잡하다
	
	join()
		- 특정 스레드가 종료될 때까지 현재 스레드를 대기 상태로 만듬
			즉, join()을 호출한 스레드가 완료되기 전까지는 다음 코드가 실행되지 않음
		- 여러 스레드를 동시에 실행할 때 특정 스레드가 종료된 후에만 
			다음 작업을 실행하고 싶을 때 사용됨(동기화 목적)
*/
```

### Future을 활용한 코드

```java
class ExecutorServiceExample{ 
	public static void main(String[] args){
		int x = 1337;
		Result result = new Result();
		
		ExecutorService executorService = Executor.newFixedThreadPool(2);
		Future<Integer> y = executorService.submit(() -> f(x));
		Future<Integer> x = executorService.submit(() -> g(x));
		System.out.println(x.get() + y.get());
		executorService.shutdown(); // 자원해제
	}
}
/*
	단점
		- 명시적인 submit(task) 같은 메소드 호출(불필요한 코드)가 추가 되었다
		- 작업의 결과를 얻어오려면 잠시라도 블로킹 상태로 들어가야 한다
		
	비동기 작업
	- executorService.submit(() -> f(x))와 executorService.submit(() -> g(x))는 
		각각 비동기적으로 실행됨 즉, 두 작업은 동시에(또는 거의 동시에) 시작되어 
		별도의 스레드에서 실행됨
		
	동기적 결과 처리
		- y.get()와 x.get()을 호출하면 해당 작업이 완료될 때까지 메인 스레드는 대기(블로킹)함 
			get()은 작업이 완료될 때까지 기다렸다가 결과를 반환(블로킹)
			즉 모두 완료될 때까지 메인 스레드는 다음 줄의 코드를 실행하지 못함
		
	Future
		- 비동기 작업의 결과를 나타내는 객체로 비동기적으로 실행된 작업의 결과를 얻을 수 있음
		- isDone() : 작업 완료여부 확인
		- cancel() : 완료되지 않은 작업 취소
		- get() : 작업의 결과 리턴, 작업이 완료될 때 까지 대기하며 완료된 후 결과 리턴
		- get(long timeout, TimeUnit unit) : 지정된 시간까지 기다린 후 결과를 반환하지 못하면
			타임아웃 발생
*/
```

위의 단점들은 스트림을 이용해 내부반복으로 바꾼것처럼 비슷한 방법으로 이 문제를 해결해야한다 문제의 해결은 비동기 API라는 기능으로 API를 바꿔서 해결할 수 있다
