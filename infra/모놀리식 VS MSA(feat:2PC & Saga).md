## 모놀리식 VS MSA

### **모놀리식 아키텍쳐(Monolithic Architecture, MA)**

하나의 통합된 코드 베이스로 여러 비즈니스 기능을 수행하는 전통적인 아키텍처 스타일이다 단일 애플리케이션 내에 서비스의 모든 로직이 들어가 있는 구조이다 쉽게 말해 하나의 큰 목적이 있는 서비스 또는 애플리케이션에 여러 기능이 통합돼 있는 구조를 의미한다

### **모놀리식 아키텍쳐의 장점**

- 간단한 유지보수
    - 단일 코드 베이스를 가지고 있기 때문에 변경 사항을 적용하고 유비보수하는 것이 상대적으로 간단하다
    - 이로 인해 코드의 일관성을 유지하고 버그를 수정하기 용이하다
- 개발 속도 향상
    - 작은 팀이나 프로젝트에서 빠른 개발이 가능하다
    - 코드베이스가 단순하고 통합이 쉬우므로 초기에 빠르게 개발하고 배포할 수 있다
- 통합의 편리함
    - 서로 다른 기능이나 모듈이 하나의 애플리케이션 안에 있으므로 통합 및 테스트가 간단하다
    - 새로운 기능을 추가하거나 변경할 때 다른 부분과의 상호작용을 고려할 필요가 적다
- 적은 인프라 구조 비용
    - 단일 애플리케이션으로 모든 것을 처리하기 때문에 인프라 구조의 복잡성이 낮아지고 운영 비용이 감소할 수 있다
- 기술 스택의 통일성
    - 단일 코드 베이스를 가지고 있기 때문에 기술 스택을 통일하기 쉽다
- 쉬운 디버깅 및 최적화
    - 단일 코드 베이스에서 발생한 문제를 디버깅하기가 비교적 간단하다
    - 모든 코드가 하나의 공간에 있기 때문에 문제를 추적하고 해결하기가 용이하다
    - 마찬가지로 최적화 또한, 코드 베이스 전체에 대한 통합된 최적화가 가능하다

이와 같은 장점은 주로 소규모 프로젝트에서 부각되며 프로젝트의 규모가 커질수록 일부분에 제약이 생길 수 있다

### **모놀리식 아키텍쳐의 단점**

- 확장과 배포의 어려움
    - 프로젝트에 새로운 기능이나 추가되거나 변경이 되면 특정 기능만 확장하여 배포하기가 어렵다
    - 작은 변경 사항도 전체 애플리케이션을 다시 배포해야 하는 경우가 있다
- 기술 스택의 제한성
    - 기술 스택을 통일시키기 쉽지만, 이는 향후 새로운 기술 도입이 어렵다는 의미가 된다
- 복잡성 증가
    - 프로젝트가 성장함에 따라 코드베이스가 커지고 복잡성이 증가할 수 있다
    - 이에 따라 코드의 일부를 이해하고 수정하는 것이 어려워 유지보수와 디버깅이 어려워질 수 있다
- 대규모 팀 작업의 어려움
    - 모든 팀이 동일한 코드, 동일한 프로젝트에서 작업하기 때문에 코드 병합에 대한 충돌 가능성이 높고, 기능 변경 시 다른 팀이 작업에 영향을 줄 수 있다

**프로젝트 규모가 작을 때, 빠른 MVP 개발이 필요할 때, 복잡한 비즈니스 로직이 필요하지 않을 때, 변경이 적은 시스템에서 적용되야할 개발 모델이다**

### **마이크로서비스 아키텍처(Microservices Architecture, MSA)**

소프트웨어 애플리케이션을 여러 작고 독립적인 서비스로 나누는 아키텍처 스타일 중 하나이다 전통적인 MA와 대조적으로, MSA는 애플리케이션을 작은 독립적인 서비스로 나누어 각 서비스가 특정 비즈니스 기능을 수행하도록 한다

### **마이크로서비스 아키텍처의 장점**

- 독립성 및 확장성
    - 각 마이크로서비스는 독립적으로 개발, 배포, 확장이 가능하며, 이는 전체 시스템의 유연성을 향상시킨다
    - 모듈간 독립적으로 유지되기 때문에 상호 의존성이 낮아진다
- 기술의 다양성
    - 각 서비스는 자체적인 기술 스택을 선택할 수 있어, 최적의 도구나 언어를 사용할 수 있다
- 쉬운 유지보수
    - 특정 서비스에 대한 다른 서비스에 미치는 영향이 적어서 유지보수가 용이하다
- 빠른 배포
    - 각 서비스는 독립적으로 배포될 수 있어서 더 빠른 배포 주기를 가질 수 있다
- 스케일링의 용이성
    - 특정 서비스에 대한 수요가 증가할 때, 해당 서비스만 확장할 수 있어 자원을 효율적으로 사용할 수 있다

### **마이크로서비스 아키텍처의 단점**

- 운영의 복잡성
    - 여러 서비스 간의 통신과 관리는 복잡성을 증가시킬 수 있다
    - 서비스 디스커버리, 로깅, 분산 추적 등을 관리해야 한다
- 데이터 일관성
    - 서비스가 독립적으로 데이터를 가지고 있을 때 일관성을 유지하기 어려울 수 있다
- 테스트의 어려움
    - 여러 서비스 간의 통합 테스트와 종단 간 테스트를 수행하기 어려울 수 있다
- 시스템 전반의 복잡성 증가
    - 전체 시스템이 여러 서비스로 이루어지므로 이를 관리하고 이해하는 데 추가적인 노력과 복잡성이 발생할 수 있다
- 시스템 전환 비용
    - 기존 MA 구조에서 MSA로의 전환은 비용과 시간이 소요될 수 있다
- 분산 시스템 문제
    - 트랜잭션 처리, 일관성 유지 등 분산 시스템의 특유한 문제에 대한 처리가 부가적으로 필요하다

마이크로서비스 아키텍처는 **대규모 및 복잡한 시스템일 때, 서비스를 만드는 독립적인 팀이 존재할 경우, 유연한 확장이 요구될 경우**에 적합한 아키텍처 스타일이다

## 2PC(Two Phase commit) & Saga Pattern

마이크로서비스는 애플리케이션을 작고 독립적인 서비스로 분할하여 특정 비즈니스 기능을 수행하도록 각 서비스를 도메인을 중심으로 분할한 서비스이다  모든 아키텍처가 그렇듯이 마이크로서비스 아키텍처에서도 **트레이드 오프가 존재**한다 기존의 모놀리식 구조보다 서비스 복잡도가 올라가고 네트워크 비용과 지연이 발생할 수 있으며 또한 분산 시스템에서는 복잡한 트랜잭션을 관리하기가 어렵고 그 때문에 일관된 트랜잭션 처리를 위한 추가 작업이 필요할 수도 있다 

기존 단일 데이터베이스 시스템에서는 데이터베이스 트랜잭션을 사용하여 여러 작업을 한 번에 처리하고, 오류가 발생하면 롤백하여 전체 데이터의 일관성을 보장할 수 있었다 그러나 서로 다른 데이터베이스를 사용하는 마이크로서비스 간에는 이러한 트랜잭션을 직접적으로 관리하기가 매우 어렵다

이러한 문제를 해결하기 위한 방안은 크게 2가지가 있다

### **1. 2PC(Two Phase Commit)**

2PC는 분산 시스템에서 트랜잭션 처리를 위해 사용되는 알고리즘 중 하나로, 참여하는 모든 시스템에서 트랜잭션을 성공적으로 처리할 수 있는지를 우선 확인하고 이후 모든 시스템에서 트랜잭션을 동시에 커밋하거나 롤백할 수 있도록 보장하는 방법이다 이 프로토콜은 안정성과 일관성을 유지하기 위해 설계되었으며 두 가지 주요 단계로 구성된다

1. 준비 단계
    - 코디네이터라고 불리는 중앙 노드가 트랜잭션을 시작하고 참여하는 모든 노드에게 트랜잭션의 준비를 요청한다
    - 참여하는 각각의 노드는 트랜잭션을 성공적으로 완료할 수 있는지 확인하고, 성공할 수 있다고 판단되면 준비 완료(Ready) 메시지를 코디네이터에게 보내고 그렇지 않다면 트랜잭션을 중단할 것을 요청하는 메시지를 보낸다
    - 이 과정에 참여하는 모든 노드는 트랜잭션을 커밋할 준비가 되었는지를 확인하지만 실제로 데이터를 변경하지는 않는다 다만 각각의 노드는 그 사이에 데이터가 변경되지 않도록 해당 데이터를 잠금 처리한다(Row Lock)
2. 커밋 또는 롤백 단계
    - 모든 참여자로부터 준비 완료 응답을 받으면 코디네이터는 각 노드에게 트랜잭션을 커밋하라는 명령을 보낸다 이때 모든 노드는 트랜잭션 변경 사항을 데이터베이스에 실제로 적용한다
    - 만약 준비 단계에서 하나라도 실패 응답을 받았거나 타임아웃 등의 문제가 발생한 경우, 코디네이터는 모든 노드에게 트랜잭션을 롤백하라는 명령을 보낸다 이런 식으로 전체 노드 간의 데이터 정합성을 유지하게 된다
        
        ```
        💡 이때 중요한 점은 커밋이든 롤백이든 관련 DB에 요청이 동시에 처리되지 않는다는 점이다
        그리고 모든 DB 요청이 처리될 때까지 해당하는 Row에 Lock이 설정되어 있다는 점이 중요하다
        ```

**2PC 장점**

- 모든 서비스가 성공할 때만 커밋하기 때문에 강한 일관성을 보장한다
- 상대적으로 이해하기 쉽고, 구현이 단순하며, 관리 비용이 적다

**2PC 단점**

- 모든 요청을 처리할 때까지 관련한 모든 DB에 Lock이 설정된다
- 서비스 간 강결합을 초래한다
- 데이터베이스가 분산 트랜잭션을 지원해야 한다(NoSQL은 2PC 패턴을 지원하지 않음)
- 모든 서비스의 응답을 기다려야 하기 때문에 리소스 점유 시간이 길다
- 코디네이터의 장애가 단일 지점 장애가 된다 모든 서비스는 코디네이터의 결정을 기다릴 때까지 블로킹 상태가 된다 만일 2PC 진행 중 코디네이터에 장애가 발생한다면, 모든 서비스는 코디네이터가 복구될 때까지 블로킹 상태가 된다

### 2. Saga Pattern

Saga Pattern은 마이크로서비스 아키텍처에서 2PC를 대체하여 분산 트랜잭션을 처리하기 위해 사용되는 알고리즘으로 여러 서비스에 걸친 데이터의 상태를 일관성있게 변경할 수 있지만 2PC와 달리 자원을 장기간 잠글 필요가 없다는 장점이 있다

2PC의 문제점들은 모든 DB 트랜잭션을 동시에 처리하기 위해 DB에 Lock을 설정하여 성능 및 결합 문제가 있었지만 Saga Pattern은 동시에 처리하지 않고 우선 순차적으로 각 DB의 트랜잭션(로컬 트랜잭션)을 처리한다

- 2PC : 관련 모든 서비스들의 DB 트랜잭션을 동시에 처리 (이를 위해 순차적으로 관련 DB에 Lock 설정)
- Saga : 관련 모든 서비스들의 DB 트랜잭션을 **순차적으로** 처리

Saga pattern은 2PC의 특징들을 다음과 같은 방식으로 대체한다

1. **모든 트랜잭션을 관리(상태 체크 & Commit/Rollback)했던 Coordinator**
    - **서비스 간의 이벤트를 통해 로컬 트랜잭션을 순차적으로 처리**
2. **트랜잭션 상태 체크 시 처리 X면 전체 트랜잭션 롤백하여 원자성 보장** 
    - **보상 트랜잭션이라는 개념을 통해 처리**

즉 Saga pattern은 로컬 트랜잭션 이벤트를 통해서 트랜잭션을 처리를 진행한다 이 과정에서 메시지 브로커를 통해 이벤트를 Pub/Sub하게 되며 원자성 보장은 하나의 트랜잭션이 롤백되었을 때 이전 이벤트를 발행했던 트랜잭션들에게 **보상 이벤트**를 발행하여 트랜잭션을 롤백하는 보상 트랜잭션을 실행한다

```
💡보상 트랜잭션이란?

보상 트랜잭션이란 물리적 개념이 아니라 롤백된 것처럼 비즈니스적으로 롤백 처리하는 것을 의미한다
즉 DB에 물리적으로 롤백을 하는것이 아닌 비즈니스 로직으로 롤백이 된 것 처럼 보상 이벤트를 주는것이다

이미 발생한 트랜잭션이 만들어낸 변경을 되돌리기 위해 새로운 트랜잭션을 추가하는것으로 고객이 이미 결제 금액을 지불했다면 지불된 돈을 돌려주는 것이고,
고객에게 포인트를 부여했다면 그 포인트를 다시 회수하는 것이 보상 트랜잭션의 예시가 될 수 있다

보통 실패할 가능성이 높은 프로세스를 앞에서 진행하여 해당 프로세스가 더 빨리 실패하면,
이후의 단계에 대해서는 보상 트랜잭션을 진행할 필요도 없으므로 로컬 트랜잭션의 실행 순서를 조정하는 것만으로도 롤백 연산의 횟수를 줄일 수 있게된다
또한 보상 트랜잭션을 구현하기 어려운 프로세스는 후반부로 실행 순서를 옮기는 것도 전체 구현의 복잡도를 낮추는 방법이다
```

Saga pattern에는 2종류로 구분할 수 있다

1. Choreographed Saga(**코레오그래피)**
    
    이벤트 및 보상 트랜잭션 처리 주체는 각 마이크로서비스의 메시지 브로커이다 해당 처리를 중앙에서 처리하는 것이 아닌 각 마이크로서비스의 메시지 브로커에서 이벤트를 Pub/Sub하면서 처리를 진행한다
    
    **장점**
    
    - 마이크로서비스가 적다면 쉽고 간단하게 구성이 가능하다
    - 기존 MSA 환경에서 추가적인 인프라 리소스가 필요하지 않다
    
    **단점**
    
    - 마이크로서비스가 많아진다면 각 서비스 간의 이벤트 구조를 파악하기가 어렵고, 의존성 순환이 발생할 위험이 있다
    - 모니터링 시에 현재 이벤트 및 트랜잭션의 상태를 추적하기가 어렵다
2. Orchestrated Saga(**오케스트레이션)**
    
    Choreographed Saga와 달리 이벤트 및 보상 트랜잭션 처리 주체로 Orchestrator가 있으며 마이크로서비스 간에 직접적으로 이벤트를 주고받았지만 Orchestrated Saga는 Orchestrator를 통해 이벤트가 다른 서비스에게 전달된다
    
    **장점**
    
    - 각 마이크로서비스의 트랜잭션 이벤트들을 Orchestrator에서 처리하기 때문에 서비스가 추가되더라도 이벤트 구조를 파악하기 쉽다
    - 마이크로서비스 간의 이벤트 순환 의존이 없다
    - 각 마이크로서비스들은 다른 마이크로서비스에 대해서 알 필요가 없어지기 때문에 결합이 적어진다
    - 트랜잭션 및 이벤트 처리가 Orchestrator에서 이루어지므로 현재 이벤트 및 트랜잭션 상태를 Orchestrator에서 쉽게 추적할 수 있다
    
    **단점**
    
    - 중앙 관리 시스템인 Orchestrator 구현을 위해 추가적인 인프라 리소스가 필요하다
    - Orchestrator가 전체 Flow를 관리하기 때문에 장애 발생 시 모든 서비스에 장애가 전파될 수 있다
    - Orchestrator 구현이 상대적으로 어렵다
