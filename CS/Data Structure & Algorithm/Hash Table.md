### Hash Table
- Hash Table은 효율적인 탐색(빠른 탐색)을 위한 자료구조로써 key-value쌍의 데이터를 입력받는다. hash function h에 key값을 입력으로 넣어 얻은 해시값 h(k)를 위치로 지정하여 key- value 데이터 쌍을 저장한다. 저장, 삭제, 검색의 시간복잡도는 모두 O(1)이다.

- Hash Table은 고정된 배열을 선언 미리 선언하고(미리 선언된 배열을 bucket 이라고 부른다) 그 후 hash function을 이용해서 key값에 맞는 hash code를 반환, hash code를 이용하여 배열의 index에 접근하여 데이터를 저장하고 조회 한다.

### Hash Collision
- Hash Collision이란 서로 다른 key의 hash값이 똑같을 때를 말한다. 즉, 중복되는 key는 없지만 hash값은 중복될 수 있는데 이 때 Collision이 발생했다고 한다. 

- Hash Collision이 발생하는 이유는 Hash function의 입력값은 무한한 반면에 출력값은 유한하기 때문에 발생한다. Hash Table은 고정된 배열(bucket)을 가지고 있기 때문에 key값이 다르다고 하여도 hash값이 같을 수 있다. 이러한 충돌로 인해서 클러스터링(연속된 레코드에 데이터가 몰리는 현상) 이나 오버플로우(버킷에 할당된 슬룻 수보다 많이 할당이 되어 더 이상 넣지 못하는 경우)가 발생한다.

### Hash Collision 해결 방법
1. Chaining
    - 버켓 내에 연결리스트(Linked List)를 할당하여, 버켓에 데이터를 삽입하다가 충돌이 발생하면 연결리스트로 데이터들을 연결하는 방식이다.
    
    장점
    1) 한정된 저장소(Bucket)을 효율적으로 사용할 수 있다.
    2) 해시 함수(Hash Function)을 선택하는 중요성이 상대적으로 적다.
    3) 연결 리스트만 사용하면 된다. 즉, 복잡한 계산식을 사용할 필요가 개방주소법에 비해 적다.

    단점
    1) 한 Hash에 자료들이 계속 연결된다면(쏠림 현상) 검색 효율을 낮출 수 있다.
    2) 외부 저장 공간을 사용한다.
    3) 외부 저장 공간 작업을 추가로 해야 한다.

2. Open Addressing(개방 주소법)
    - 해시 충돌이 일어난 경우, 특정한 간격만큼 이동 후 비어있는 주소 값에 저장하는 방식이다. 개방 주소법은 대표적으로 3가지가 있다.

    1) 선형 탐사(Linear Probing): 충돌이 발생하면 다음 슬롯을 순차적으로 검사하여 빈 슬롯을 찾아 키를 삽입한다. 선형적인 방법이기 때문에 일정한 간격으로 탐사를 진행한다.

    2) 이차 탐사(Quadratic Probing): 충돌이 발생하면 탐사 시도의 제곱에 비례하는 간격으로 다음 슬롯을 검사한다. 선형 탐사보다 더 분산된 위치를 찾을 수 있다.

    3) 이중 해싱(Double Hashing): 충돌이 발생하면 두 번째 해시 함수를 사용하여 새로운 위치를 찾는다. 이중 해싱은 두 해시 함수가 독립적이어야 하며, 하나는 최초의 해시값을 얻을 때 사용하고 또 다른 하나는 해시 충돌이 발생할 때 탐사 이동폭을 얻기 위해 사용한다.

    장점
    1) 개방 주소법은 체이닝(Chaining)과 달리 포인터 및 추가적인 데이터 구조가 필요하지 않아 메모리 효율성이 높다.

    2) 데이터가 연속적인 메모리 위치에 저장되므로, 순차적인 접근이 다른 해시 충돌 해결 방법에 비해 효율적일 수 있다.

    단점
    1) 개방 주소법은 클러스터링 현상이 발생할 수 있다. 특히 선형 탐사에서는 일정한 간격으로 이어지는 슬롯에 데이터가 모이는 경우가 발생하며, 이로 인해 충돌이 더 자주 발생할 가능성이 있다.

    2) 충돌이 발생할 경우 성능이 감소할 수 있다. 선형 탐사와 같이 일정 간격으로 이동하면서 새로운 위치를 찾기 때문에 일부 위치에서는 충돌이 계속해서 발생할 수 있다.

    3) 적재율이 높아질 경우 성능이 더욱 감소할 수 있다. 충돌이 많이 발생하면 적절한 해시 함수나 충돌 해결 전략을 선택해야 한다.