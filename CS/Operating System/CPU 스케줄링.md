### CPU 스케줄링
- CPU가 하나의 프로세스 작업이 끝나면 다음 프로세스 작업을 수행해야 한다 이때 어떤 프로세스를 다음에 처리할 지 선택하는 알고리즘을 CPU 스케줄링 알고리즘 이라고 한다 
- 상황에 맞게 CPU를 어떤 프로세스에 배정하여 효율적으로 처리하는가가 관건이다

### 선점 / 비선점 스케줄링
- 선점 (preemptive)
    - 프로세스가 CPU를 점유하고 있는 동안 I/O나 인터럽트가 발생하지 않았음에도 다른 프로세스가 강제로 CPU를 점유하여 실행(Timeout, I/O 인터럽트, System Call 등이 발생할 때도 선점 가능)
    - Context Switching으로 인한 오버헤드가 발생
    - 대부분의 저수준 스케줄러는 선점형 스케줄링 방식을 사용
        - 저수준 스케줄러 : 어떤 프로세스에 CPU를 할당할지, 어떤 프로세스를 대시 상태로 보낼지 등을 결정하는 일을 함

- 비선점 (nonpreemptive) 
    - 프로세스 종료 or I/O 등의 이벤트가 있을 때까지 실행 보장
    - Context Switching에 대한 오버헤드도 없고 스케줄러가 할 일도 적어져 효율적일 수 있으나 전체 시스템의 처리율이 떨어지게 됨

### 비선점 스케줄링
1. FCFS(First come First Served)
    - 준비 큐에 먼저 도착한 프로세스가 먼저 CPU를 점유하는 방식
    - CPU를 할당 받으면 CPU 점유 시간이 완료 될때 까지 CPU를 반환하지 않으며 할당되었던 CPU가 반활될 때만 스케줄링이 이루어짐
    - 먼저 들어온 프로세스의 CPU 점유 시간이 길면 뒤에 들어온 프로세스들이 오래 기다려야 하는 단점이 있음(먼저 들어온 프로세스가 CPU 점유 시간이 길면 평균 대기 타임이 늘어나기 때문)

2. SJF(Shortest Job First)
    - 먼저 들어온 프로세스 보다 CPU 점유 시간이 짧은 프로세스가 있다면 CPU를 먼저 할당하는 방식
    - SJF가 가장 효율적인 CPU 스케줄링 방법 같지만, 매우 비현실적임(컴퓨터 환경에서는 프로세스의 CPU 점유 시간을 알 수 없기 때문) 
    - 한 프로세스가 실행 중에는 많은 변수가 존재하기 때문에 CPU 점유 시간을 알려면 실제로 수행하여 측정하는 수밖에 없음 
    - 실제 측정한 시간으로 예측하여 SJF를 사용할 수도 있지만, 이는 오버헤드가 매우 큰 작업으로 잘 사용되지 않음

### 선점 스케줄링
1. SRTF(Shortest Remaining Time First)
    - 실행 시간이 짧은 순서대로 프로세스를 수행
    - 현재 CPU에서 실행 중인 프로세스의 남은 CPU 점유 시간보다 더 짧은 CPU 점유 시간을 가지는 프로세스가 도착하면 짧은 시간을 가진 프로세스가 CPU를 선점
    - 이렇게 되면 CPU 점유 시간이 긴 프로세스는 계속 뒤로 밀려나 Starvation(기아현상)이 발생할 수 있음

2. Priority Scheduling (선점, 비선점 모두 사용 가능)
    - 우선순위가 높은 프로세스가 먼저 선택되어 수행
    - 우선순위는 정수값으로 나타내며 작은 값이 우선순위가 높음(Linux, Unix 기준)
    - 우선 순위가 낮은 프로세스가 무한정 기다리는 Starvation(기아현상)이 생길 수 있음
    - Aging 방법으로 Starvation(기아현상) 문제 해결 가능
        - aging : ready queue에서 기다리는 동안 일정 시간이 지나면 우선 순위를 일정량 높여주는 것
    - 우선순위를 정하는 방법
        - Internal : time limit, memory requirement, I/O to CPU burst(I/O 작업은 길고, CPU 작업은 짧은 프로세스 우선) 등
        - External : amout of funds being paid, political factors 등

3. Round Robin Scheduling
    - 시분할 시스템의 성질을 활용한 방법으로 일정 시간을 정하여 하나의 프로세스가 이 시간동안 수행하고 다시 대기 상태로 돌아감
    - 이러한 작업을 모든 프로세스가 돌아가면서 진행하며, 마지막 프로세스가 끝나면 다시 처음 프로세스로 돌아와서 작업을 반복
    - 일정 시간을 Time Quantum(Time Slice)라고 부르며 일반적으로 10 ~ 100msec 사이의 범위를 갖음
    - Time Quantum이 너무 짧으면 Context Switching이 자주 일어나 오버헤드가 발생
    - 한 프로세스가 종료되기 전에 time quantum이 끝나면 다른 프로세스에게 CPU를 넘겨주기 때문에 선점형 스케줄링의 대표적인 예시

4. Multilevel Queue(다단계 큐)
    - 프로세스를 그룹으로 나누어 우선순위가 낮은 큐들이 실행 못하는 걸 방지하고자 각 큐마다 다른 Time Quantum을 설정 해주는 방식 사용
    - 우선순위가 높은 큐는 작은 Time Quantum 할당 우선순위가 낮은 큐는 큰 Time Quantum 할당
    - 우선순위가 높은 상위 큐에 프로세스가 게속 들어오게 된다면 하위 큐에 들어 있는 프로세스는 작업을 할 수 없는 단점이 있음

5. Multilevel Feedback Queue
    - 기본 개념은 Multilevel Queue와 동일하나 단점을 해소하기 위해 프로세스가 하나의 큐에서 다른 큐로 이동이 가능
    - CPU를 사용하고 난 프로세스는 우선순위가 낮아져 원래 큐로 돌아가지 않고 우선순위가 하나 낮은 큐의 끝으로 들어가게 됨
    - 이렇게 되면 상위 큐의 작업 프로세스들이 우선 순위가 계속 낮아져 하위 큐의 프로세스들과 같은 우선순위가 되어 하위 큐의 프로세스들도 CPU를 할당 받을 수 있음
        - 상위 큐에 프로세스가 계속 들어오게 되면 aging 기법을 사용해 우선순위를 올려줄 수도 있음
    - 우선순위가 낮아 질 수록 Time Quantum은 길어지기 때문에 마지막에 있는 큐에 들어 있는 프로세스는 무한대의 Time Quantum를 얻게 됨
        - 무한대의 타임 퀀텀을 얻는다는 것은 프로세스가 실행상태가 들어가면 cpu 를 빼앗기지 않고 끝까지 작업을 마친다는 의미
        - 그러므로 다단계 피드백 큐 스케줄링에서 마지막 큐는 들어온 순서대로 작업을 마치는 FCFS 스케줄링 방식으로 동작
