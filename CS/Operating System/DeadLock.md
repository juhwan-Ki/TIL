### 데드락(DeadLock)
- 데드락이란 두 개 이상의 process/thread가 서로 자원을 얻지 못해 다음 처리를 하지 못하고 무한정 기다리는 상태를 의미한다 한정된 자원을 여러 곳에서 사용하려고 할 때 발생한다

- 데드락이 일어나는 경우
    - process1과 process2가 자원 1,2를 모두 얻어야 한다고 가정했을 때 
        <br> t1 : 프로세스1이 자원1을 얻음 / 프로세스2가 자원2를 얻음
        <br> t2 : 프로세스1은 자원2를 기다림 / 프로세스2는 자원1을 기다림    
    - 현재 서로 원하는 자원이 상대방에게 할당 되어 있어 두 프로세스는 무한정 wait 상태에 빠지게 됨

- 주로 발생하는 경우
    - 멀티 프로그래밍 환경에서 한정된 자원을 얻기 위해 서로 경쟁하는 상황 발생
    - 한 프로세스가 자원을 요청했을 때, 동시에 그 자원을 사용할 수 없는 상황이 발생할 수 있음 이때 프로세스는 대기 상태로 들어감
    - 대기 상태로 들어간 프로세스들이 실행 상태로 변경될 수 없을 때 데드락 발생

### 데드락 발생 조건
- 4가지 모두 성립해야 데드락이 발생한다(한 가지라도 성립하지 않으면 데드락이 발생하지 않음)

1. 상호 배제(Mutual Exclusion)
    - 자원은 한번에 한 프로세스만 사용할 수 있음

2. 점유 대기(Hold and Wait)
    - 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당 되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 존재해야 함

3. 비선점(No Preemption)
    - 다른 프로세스에 할당된 자원은 사용일 끝날 때 까지 강제로 빼았을 수 없음

4. 순환 대기(Circular Wait)
    - 공유 자원과 공유 자원을 사용하기 위해 대기하는 프로세스들이 원형으로 구성되어 있어 자신에게 할당된
    자원을 점유하면서 앞이나 뒤에 있는 프로세스의 자원을 요구해야 함

### 데드락 예방 
- 데드락 발생 조건 중 하나를 제거하여 데드락이 발생하지 않도록 예방하는 방법(자원 낭비가 매우 심함)

1. 상호배제 부정 : 여러 프로세스가 공유 자원을 사용하도록 허용
    - 공유 자원에 대한 관리가 이루어질 수 없고 프로그램이 제대로 작동될 수 없어 현실적으로 불가능

2. 점유대기 부정 : 프로세스 실행 전 필요한 모든 자원을 할당
    - 프로세스에게 필요한 자원에 대한 정보를 미리 파악하는 과정에서 많은 시간 및 비용이 발생
    - 많은 자원들이 사용되지 않으면서 오랫동안 할당만 되어 있기 때문에 자원의 효율성이 매우 낮아짐

3. 비선점 부정 : 자원을 점유 중인 프로세스가 다른 자원을 요구 할 때 가진 자원을 반납
    - 공유 자원에 대한 동기화에 의미가 깨져 실질적으로 불가능한 방법

4. 순환 대기 부정 : 선형 대기로 만들어 순차적으로 필요한 자원을 획득한 후 실행
    - 중첩 되어 있는 공유 자원 사이에 요청 순서를 임의로 정하여 여러 개의 프로세스가 순환 대기에 머물러 있는 것을 방지
    - 그나마 주로 사용하는 방법

### 데드락 회피 
- 데드락이 발생할 가능성을 0으로 만드는 것이 아닌 발생하더라도 피해가는 기법
- 대표적으로 은행원 알고리즘이 사용됨

- 은행원 알고리즘
    - 최소한 하나의 프로세스에게 할당해줄 만큼의 자원은 항상 CPU가 보유하고 있어야 하는 개념
    - 특정 자원을 프로세스에게 할당할 때 할당으로 인해 데드락에 빠질 가능성이 있는지 사전에 판단하여 안전 상태와 불안전 상태로 나누는 것을 의미
    - 자원 요청 시 안전 상태이면 자원을 사용하게 하고 불안전 상태이면 안전 상태가 될 때 까지 계속 요청을 거절
        - 안전 상태 : 시스템이 데드락을 일으키지 않고 프로세스가 완료될 수 있는 상태
        - 불안전 상태 : 데드락일 발생할 수 있는 상태
    
- 은행원 알고리즘 단점
    1. 할당할 수 있는 자원의 수가 일정해야 함(할당할 자원을 미리 파악해야 하기 때문)
    2. 프로세스의 수가 일정해야함
    3. 항상 안전상태를 유지해야 하기 때문에 자원에 대한 이용률이 낮음
    4. 프로세스가 요구하는 최대 자원 요구량을 미리 알아야함
    5. 프로세스들은 반드시 유한 시간 내에 사용한 자원을 반납해야함

### 데드락 회복
- 데드락 발생 시 데드락을 해결하기 위한 기법
- 사용자 직접 처리 방법과 시스템을 사용한 자동 회복 방법으로 나뉨

- 사용자 직접 처리
    - 데드락에 걸려있는 프로세스 중 하나의 프로세스를 사용자가 강제로 종료시켜 해결하는 방법

- 시스템을 통한 자동 회복 방법
    1. 프로세스 중지 : 한 개 이상의 프로세스를 중지하여 데드락을 회복하는 기법
        - 교착 상태의 프로세스를 모두 중지하는 방법
            - 확실하게 해결이 가능하지만 비용이 많이 발생(연산 결과를 폐기하고 다시 처음부터 진행해야 하기 때문)
        - 교착 상태가 제거될 때까지 하나씩 프로세스 중지 방법
            - 모두 중지하는 방법보다 비용이 덜 들지만 모든 프로세스를 탐색해야 하기 때문에 오버헤드가 큼
    
    2. 자원 선점 : 프로세스들로 부터 자원을 빼았아 회복될 때 까지 다른 프로세스에게 할당 하는 방법
        - 선점 프로세스 선택(희생자 선택)
            - 필연적으로 종료되어야 할 프로세스의 선택은 비용 최소화를 위해 선점 순서를 결정해야함
            - 비용의 요인은 점유하고 있는 자원의 수, 실행된 시간 등으로 결정
        - 복귀(Rollback)
            - 데드락을 해결하기 위해 완전히 중지시킨 후 재시작 하는 방법
        - 기아(Starvation)
            - 희생자를 선택할 때 주로 비용에 근거하여 처리하기 때문에 동일한 프로세스가 지속해서 희생자로 선택이 될 수 있음
            - 그 결과 자신의 일을 수행하지 못하고 굶어버리는 기아상태가 되기 쉽기 때문에 희생자를 선택할 때 한정된 시간 동안에만 희생될 것을 보장해야 함
        
