### Deadlock
- 데드락이란 여러개의 트랜잭션들이 실행을 하지 못하고 서로 무한정 기다리는 상태를 의미한다
- 데이터베이스에서는 기본적으로 트랜잭션들의 동시성을 제어하기 위해 잠금(Locking)을 사용한다 이러한 잠금은 데이터의 무결성을 지켜주지만 그 부작용으로 데드락(교착상태)가 발생할 수 있다

- Lock
    - Lock이란 트랜잭션 처리의 순차성을 보장하기 위한 방법이다
    - 종류
        1. 공유(Shared) Lock
            - 공유 Lock은 데이터를 읽을 때 사용되어지는 Lock이다 이런 공유 Lock은 공유 Lock 끼리는 동시에 접근이 가능하다 즉, 하나의 데이터를 읽는 것은 여러 사용자가 동시에 할 수 있다 하지만 공유 Lock이 설정된 데이터에 베타 Lock을 사용할 수는 없다
        2. 베타(Exclusive) Lock
            - 베타 Lock은 데이터를 변경하고자 할 때 사용되며, 트랜잭션이 완료될 때까지 유지된다 베타락은 Lock이 해제될 때까지 다른 트랜잭션(읽기 포함)은 해당 리소스에 접근할 수 없다 또한 해당 Lock은 다른 트랜잭션이 수행되고 있는 데이터에 대해서는 접근하여 함께 Lock을 설정할 수 없다

- 데드락 해결 방법
1. 예방 기법
    - 각 트랜잭션이 실행되기전에 필요한 데이터를 모두 락을 거는 것을 말한다 <br>
    하지만 데이터가 많이 필요할 경우 모든 데이터를 잠금해야 되기 때문에 트랜잭션의 병행성을 보장하지 못한다 뿐만 아니라 몇몇 트랜잭션들은 계속해서 처리를 못하게 되는 기아 상태가 발생할 수 있다

2. 회피 기법
    -  예방 기법의 단점을 해결하기 위한 방법으로 실제로 데드락을 해결하기 위한 방법으로 회피 기법이 많이 사용된다 <br>
    회피 기법은 자원을 할당할 때 시간 스탬프(Time Stamp)를 사용하여 데드락이 일어나지 않도록 회피하는 방법으로 Wait-Die 방식과 Wound-Wait 방식이 있다

    1) Wait-Die (비선점)
    - 다른 트랜잭션이 데이터를 점유하고 있을 때 기다리거나(Wait) 포기(Die)하는 방식으로 선행 트랜잭션이 접근하면 대기(wait), 후행 트랜잭션이 접근하면 포기(die)한다 <br>
    즉, 오래된 프로세스에게 대기의 기회를 제공하고, 최신 프로세스는 자주 복귀함으로써 오버헤드의 가능성이 있다
    - Time Stamp가 높을 수록 후행 트랜잭션

    2) Wound-Wait (선점)
    - 다른 트랜잭션이 데이터를 점유하고 있을 때 빼앗거나(Wound) 기다리는(Wait) 방식으로 선행 트랜잭션이 접근하면 선점(wound), 후행 트랜잭션이 접근하면 대기(wait)한다 <br>
    즉, 오래된 프로세스에게 선점의 기회를 제공하고 최신 프로세스는 대기함에 따라 복귀를 최소화한다

3. 탐지/회복 기법
    - 트랜잭션이 실행되기 전에는 아무런 검사를 하지 않고, 데드락이 발생하면 이를 감지하고 회복시키는 방법

- 데드락 빈도를 낮추는 방법
    1. 트랜잭션을 자주 커밋한다
    2. 정해진 순서로 테이블에 접근한다
    3. Deadlock 예방을 위한 것이 아닌 읽기 잠금 획득(SELECT ~ FOR UPDATE)의 사용을 피한다
    4. 한 테이블의 복수 행을 복수의 연결해서 순서 없이 갱신하면 교착 상태가 발생하기 쉽다 이 경우에는 테이블 단위의 잠금을 획득해 갱신을 직렬화하면 동시성이 떨어지지만 교착 상태를 피할 수 있다
