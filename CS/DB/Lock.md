### DB Lock이란?

- 같은 자원에 동시에 접근하는 경우가 발생했을 때 데이터의 일관성과 무결성을 유지해야할 필요가 있다
- Lock은 트랜잭션 처리의 순차성을 보장하기 위한 방법으로 데이터의 일관성과 무결성을 유지하기 위해 사용한다
- 즉 트랜잭션의 동시성을 제어하기 위해 사용된다
    - Isolation Level은 connection 단위로 적용이 가능
    - Lock은 transaction
- Lock의 종류로는 공유(Shared) Lock과 베타(Exclusive) Lock이 있으며 공유락은 다른말로 Read Lock 이라 불리며 베타락은 Write Lock이라고 불린다

### Lock의 종류

- 공유(Shared) Lock
    - 데이터를 읽을 때 사용되어지는 락으로 공유 락끼리는 동시에 접근이 가능하다
    - 즉 하나의 데이터를 읽는 것은 여러 사용자가 동시에 할 수 있다
    - 공유 락이 걸린 데이터에 대해서 읽기 연산만 실행이 가능하며 쓰기 연산은 실행이 불가능하다
    - 공유 락이 설정된 데이터에 베타 락을 설정할 수는 없다
    - 공유 락을 사용하면 조회한 데이터가 트랜잭션 내내 변경되지 않음을 보장한다
    - `Select For Share` 를 통해 공유 락을 얻을 수 있다
        
        ```sql
        	SELECT * FROM table_name WHERE id = 1 FOR SHARE;
        ```
        
- 베타 (Exclusive Lock) Lock
    - 데이터의 변경을 위해 사용하는 락으로 데이터에 대해 베타 락을 확득한 트랜잭션은 읽기 연산과 쓰기 연산을 모두 수행할 수 있다
    - 다른 트랜잭션은 베타 락이 걸린 데이터에 대해 읽기 작업, 쓰기 작업 모두 수행할 수 없다
    - 즉 베타 락이 걸려 있으면 다른 트랜잭션은 공유 락 베타 락 모두 획득할 수 없다
    - 베타 락을 사용하면 해당 데이터에 대한 독점권을 갖는 다고 할 수 있다
    - `Select For Update`를 통해 베타 락을 얻을 수 있다
        
        ```sql
        SELECT * FROM table_name WHERE id = 1 FOR UPDATE;
        ```

### 잠금 없는 읽기

- My Sql의 InnoDB 스토리지 엔진을 사용하는 테이블에서는 한 가지 주의할 점이 있다
- **`FOR UPDATE`** 혹은 **`FOR SHARE`** 절을 가지지 않는 **`SELECT`** 쿼리는 잠금 없는 읽기가 지원된다
- 따라서 특정 데이터가 **`FOR UPDATE`** 로 락이 걸린 상태라도 **`FOR UPDATE`** , **`FOR SHARE`** 가 없는 단순 **`SELECT`** 쿼리는 아무런 대기 없이 해당 데이터를 조회할 수 있다

### Blocking

- Lock 간(베타 - 베타, 베타 - 공유)의 경합이 발생해서 특정 트랜잭션이 작업을 진행하지 못하고 대기하는 상태를 의미한다
- 블로킹을 해소하기 위해서는 이전의 트랜잭션이 Commit or Rollback 되어야 한다
- Lock의 Timeout 시간 이전에 트랜잭션이 종료되지 않으면 Error가 발생하고 트랜잭션이 Rollback되어 종료 된다
- 뒤에 들어오는 트랜잭션은 이전 트랜잭션이 마무리 되어야 이후 진행이 가능하게 된다
- 해결 방안
    - 트랜잭션 작업 단위를 최대한 작게 구성
        - 작업 단위를 작게 구성하게 되면 그만큼 트랜잭션이 빠르게 종료되기 때문에 블로킹 상태 해결이 빠르게 진행됨
    - 동일한 데이터를 동시에 변경하는 작업을 하지 않도록 설계
    - 쿼리를 오랜시간 잡아두지 않도록 적절한 튜닝이 필요

### DeadLock(교착 상태)

- 두 트랜잭션이 각각 Lock을 설정한 다음 서로의 Lock에 접근하여 값을 얻어오려고 할 때 이미 각각의 트랜잭션에 의해 Lock이 설정되어 있어 양쪽 트랜잭션에서 모두 영원히 처리가 되지 않는 현상을 말한다
    - TR1에서 table1번의 1번 row를 수정하고 table2번의 2번 row를 수정하려고 한다
    - TR2에서 table2번의 2번 row를 수정하고 table1번의 1번 row를 수정하려고 한다
    - 이렇게 되면 서로 베타 락이 걸려 있어 접근을 하지 못하는 상태가 발생하여 영원히 처리 되지 못하는 DeadLock(교착 상태)에 빠지게 된다
- 해결방법
    - DeadLock 감지
        - 데드락을 자동으로 감지하여 데드락 상황이 되면 하나의 트랜잭션을 롤백하고 종료하여 데드락을 해결한다
            
            ```sql
            set global innodb_deadlock_detect=off;
            ```
            
        - Timeout 설정을 통해 특정 시간동안 트랜잭션이 일정 수준의 작업을 수행하지 않으면 해당 트랜잭션을 롤백 시킴
    - DeadLock 방지
        - 타임스탬프 활용
            - Wait-Die: 트랜잭션 B가 선점하고 있는 데이터를 A가 요청할 때, A가 먼저 들어온 트랜잭션일 경우 wait(대기) / A가 나중에 들어온 트랜잭션일 경우 die(포기)
            - Wound-Die: 트랜잭션 B가 선점하고 있는 데이터를 A가 요청할 때, A가 먼저 들어온 트랜잭션일 경우 Wound(선점) / A가 나중에 들어온 트랜잭션일 경우 die(포기)
        - 서비스 로직 변경
        - 격리수준 변경
