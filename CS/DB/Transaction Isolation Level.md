### 트랜잭션 격리 수준(Transaction Isolation Level)이란?

- 여러 트랜잭션이 동시에 처리될 때, 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 여부를 결정하는 것이다
- 데이터베이스는 트랜잭션의 독립적인 수행을 위해 Locking을 사용하여 트랜잭션이 수행되는 동안 다른 트랜잭션이 관여하지 못하도록 해야한다
- 하지만 Locking으로 인해 동시에 수행되는 트랜잭션을 순차대로 수행을 하게 하면 성능이 많이 떨어 질수 있으므로 적절한 Locking이 필요하다
- 트랜잭션의 격리 수준은 격리(고립) 수준이 높은 순서대로 SERIALIZABLE, REPEATABLE READ, READ COMMITTED, READ UNCOMMITED가 존재한다

### READ UNCOMMITED

- READ UNCOMMITED은 다른 트랜잭션에서 커밋되지 않은 데이터에 접근할 수 있게 하는 격리 수준으로 가장 저수준의 격리수준이며, 일반적으로 사용하지 않는 격리수준이다
- 하나의 트랜잭션에서 데이터를 변경 한 후 커밋을 하지 않은 상태에서 또 다른 트랜잭션이 데이터를 조회하면 커밋되지 않은 데이터가 조회된다
- 이때 트랜잭션이 커밋을 하지 않고 롤백을 하게되면 데이터 부정합을 발생시킬 수 있다
- 이렇게 커밋 되지 않은 트랜잭션에 접근하여 부정합을 유발할 수 있는 데이터를 읽는 상황을 Dirty Read라고 한다

### READ COMMITTED

- READ COMMITTED은 커밋이 완료된 트랜잭션의 변경사항만 다른 트랜잭션에서 조회할 수 있도록 허용하는 격리 수준이다 즉, 특정 트랜잭션이 이루어지는 동안 다른 트랜잭션은 해당 데이터에 접근할 수 없다
- 대부분의 DBMS에서 기본으로 사용하는 격리 수준이다 (MySQL은 REPEATABLE READ 사용)
- 데이터 변경 후 커밋되기 전까지는 데이터 조회 시 실제 테이블에서 데이터를 가져오는 것이 아닌 Undo 영역에 백업된 데이터를 조회하고 커밋이 완료되면 테이블에서 데이터를 조회하도록 동작한다
- 이때 한 트랜잭션 내에서 반복 읽기(같은 SELECT문을 수행)를 수행하면 다른 트랜잭션의 커밋 여부에 따라 조회 결과가 달라지는 문제 발생할 수 있는데 이러한 문제를 Non-repeatable Read 라고 한다

> Undo 영역
> 
> - 트랜잭션 롤백을 위해 사용되는 로그가 남는 영역으로 변경 전 데이터가 저장된다
> - **Undo Log Buffer** 형태로 **메모리**에 저장되고, 특정 시점에 디스크에 저장된 **Undo Log File**에 I/O 작업으로 쓰여진다
> - 메모리에 입력을 하기 때문에 Disk I/O 작업을 하는 것 보다 성능이 좋다

### EPEATABLE READ

- REPEATABLE READ는 커밋된 데이터만 읽을 수 있되 자신보다 낮은 트랜잭션 번호를 갖는 트랜잭션에서 커밋한 데이터만 읽을 수 있는 격리수준이다
- 트랜잭션은 고유한 번호를 가지며 Undo 영역에 백업된 모든 레코드에는 변경을 발생시킨 트랜잭션의 번호가 포함되어 있어 하나의 트랜잭션 안에서 일어나는 모든 SELECT는 자신의 트랜잭션 번호보다 작은 트랜잭션 번호에서 변경한 사항들만 볼 수 있다 이러한 방식을 MVCC라고 한다
- REPEATABLE READ에서는 `SELECT ... FOR UPDATE` 쿼리와 같은 쓰기 잠금을 거는 경우 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다가 안 보였다가 하는 현상인 Phantom Read가 발생할 수 있는데  그 이유는 Undo 영역에서 데이터를 가져와 보여주고 있는데 Undo 영역은 잠금(Lock)을 할 수 없어 Undo 영역의 값이 아닌 실제 테이블에 있는 값을 보여기 때문이다

> MVCC(Multiversion Concurrency Control)
> 
> - 다중 버젼 동시성 제어의 약자로 DBMS에서 서로 다른 세션이 동일한 데이터에 접근했을 때 각 세션마다 스냅샷 이미지를 보장해주는 매커니즘으로 RDBMS에서 동시성을 높이기 위해 등장한 기술이다
> - MVCC의 가장 큰 목적은 Lock을 사용하지 않는 일관된 읽기를 제공하기 위함이며 데이터의 여러 버전을 유지함으로써, 다수의 트랜잭션이 동시에 데이터에 접근할 수 있어 동시성을 크게 향상시킨다
> - 하지만, 추가적인 저장공간이 필요하며 오래된 데이터 버전을 정리하는 과정이 필요하다

### SERIALIZABLE

- SERIALIZABLE은 가장 엄격한 격리 수준으로, 이름 그대로 트랜잭션을 순차적으로 진행시킨다
- SERIALIZABLE에서 여러 트랜잭션이 동일한 레코드에 동시 접근할 수 없으므로, 어떠한 데이터 부정합 문제도 발생하지 않는다 하지만 트랜잭션이 순차적으로 처리되어야 하므로 동시 처리 성능이 매우 떨어진다
- SERIALIZABLE은 가장 안전하지만 가장 성능이 떨어지므로, 극단적으로 안전한 작업이 필요한 경우가 아니라면 사용해서는 안된다

### 정리

- **READ UNCOMMITTED**
    - 한 트랜잭션의 변경된 내용을 커밋이나 롤백과 상관 없이 다른 트랜잭션에서 읽을 수 있는 격리 수준
    - 모든 부정합 문제 발생
- **READ COMMITTED**
    - COMMIT이 완료된 데이터만 조회 가능한 격리 수준
    - Dirty Read 해결
- **REPEATABLE READ**
    - 트랜잭션이 시작되기 전에 커밋된 내용에 관해서만 조회할 수 있는 격리 수준
    - MVCC로 NON-REPEATABLE-READ 해결
- **SERIALIZABLE**
    - 한 트랜잭션을 다른 트랜잭션으로부터 완전히 분리하는 격리 수준
    - 모든 부정합 문제 해결
