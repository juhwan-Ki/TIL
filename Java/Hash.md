## Hash 알고리즘
Hash 알고리즘은 데이터를 빠르게 저장하고 검색하기 위한 방법으로, key를 해시 함수(Hash Function)에 전달하여 배열의 인덱스로 변환한 뒤 해당 인덱스에 데이터를 저장하는 방식이다
이러한 구조를 해시 테이블(Hash Table)이라 하며, `key-value` 형태의 데이터를 빠르게 조회할 수 있다
### 해시 알고리즘 처리 방식
- `Key` → `Hash Function` → `Hash Index` → `Hash Table` 저장 및 조회순으로 처리
- `key, value`의 형태의 해시는 해시 함수를 통해서 key의 값은 `해시 값`으로 변환
- 이 변환된 해시 값을 기반으로 해시 인덱스를 결정하여 해시 테이블에는 해시 인덱스와 고유한 해시 값이 저장
- 탐색을 위해서는 key를 호출하면 인덱스를 찾아서 값을 반환해 주기에 빠르게 조회가 가능
#### 1. 키(Key)  
- 해시 알고리즘에서 key는 문자열 또는 숫자 등 다양한 형태가 될 수 있으며, 데이터에 접근하기 위한 고유 식별자 역할을 한다
- key 값은 해시함수(Hash Function)의 입력으로 사용되며 항상 동일한 키는 항상 동일한 해시값을 반환해야 한다
#### 2. 해시 함수(Hash Function)
- 전달받은 key값을 통해서 해시 함수가 수행되며 해시 함수 내에서는 key를 해시값으로 변환한다
- 또한 변환된 해시 값은 해시 테이블(Hash Table)의 해시 인덱스(Hash Index)로 저장된다
- 해시 함수의 주요 목표
	1. 빠르게 계산할 수 있어야 함
	2. 서로 다른 키가 되도록이면 다른 해시값을 만들도록 설계되어야 함
	3. 균등하게 분산된 결과를 생성해야 함 → 해시 테이블의 클러스터링 방지
- `주의`: 해시 함수가 생성하는 값은 `고유(unique)`하지 않을 수 있으며 충돌이 언제든 발생할 수 있다
- 좋은 해시 함수의 조건
	1. 빠른 연산 속도: 실시간 처리를 고려해 연산이 가벼워야 함
	2. 균등한 분포: 해시 값이 가능한 한 전체 인덱스에 고르게 분포되어야 함
	3. 충돌이 적게 발생:  서로 다른 key가 같은 해시 값을 갖지 않도록 설계
	4. 입력 값의 작은 변화에 민감: key가 조금만 바뀌어도 해시 값이 많이 달라져야 함 
#### 3. 해시 테이블(Hash Table)
- 배열 기반의 자료구조로 해시 값은 배열의 인덱스로 매핑되며, 해당 위치에 `key-value` 쌍이 저장된다
- 해시값을 사용하여 빠르게 값을 검색할 수 있다
- 탐색 속도는 평균 `O(1)` (단, 충돌이 적을 경우에 한함)
#### 4. 해시 충돌
- 서로 다른 키가 동일한 해시 값을 가질 때 발생하는 현상으로 해시 함수의 특성상 피할 수 없는 문제로 이를 해결하기 위한 다양한 기법들이 존재한다
#####  4-1 해시 충동 해결방법(Collision Resolution Technique) 종류
1.  체이닝 (Chaining)
	- 같은 인덱스에 여러 값을 저장할 수 있도록 `연결 리스트(Linked List 또는 List)`를 사용
	- 버킷마다 리스트가 존재하며, 충돌 시 해당 리스트에 데이터를 추가
    - 장점: 해시 테이블 크기보다 많은 데이터를 저장 가능
    - 단점: 탐색 속도는 O(n)에 가까워질 수 있음
2. 개방주소법 (Open Addressing)
	- 충돌 시 빈 인덱스를 찾아 이동하여 데이터를 저장
	- 장점: 지정한 메모리 외 추가적인 저장공간도 필요없어 메모리를 더 적게 사용
    - 단점 : 클러스터링 문제가 발생할 수 있음
	-  개방 주소법은 대표적으로 3가지가 있음
		- 선형 탐색(Linear Probing): 해시충돌 시 다음 버켓, 혹은 몇 개를 건너뛰어 데이터를 삽입
		- 제곱 탐색(Quadratic Probing): 해시충돌 시 제곱만큼 건너뛴 버켓에 데이터를 삽입
		- 이중 해시(Double Hashing): 해시충돌 시 다른 해시함수를 한 번 더 적용한 결과를 이용
#### Load Factor (부하율)

- 정의: `Load Factor = 저장된 요소 수 / 해시 테이블 크기`
- 부하율이 높아질수록 해시 충돌 가능성이 커지고, 탐색/삽입 성능이 저하됨
- 일반적으로 `0.7 이하`를 유지하도록 설계함 (Java의 `HashMap` 기본값도 0.75)
#### Rehashing (재해싱)
- 정의: 해시 테이블의 용량이 부족하거나 Load Factor가 임계값을 초과할 경우, 더 큰 배열로 확장 후 전체 요소를 다시 해싱하는 과정
- 과정
	- 더 큰 배열을 새로 할당
	- 기존의 key들을 새로운 배열에 다시 해시 → 새 인덱스에 배치    
- 단점: 비용이 크기 때문에 자주 발생하지 않도록 조절이 필요
