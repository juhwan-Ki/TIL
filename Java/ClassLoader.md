### 클래스 로더(ClassLoader)
- 자바는 동적 로드, 즉 컴파일 타임이 아니라 런타임(바이트 코드를 실행 시)에 클래스를 로드하고 링크하는 특징이 있다
- 클래스 로더는 런타임 중에 JVM 메소드 영역에 동적으로 java 클래스를 로드하는 역할을 하며 로딩, 링크, 초기화 단계로 나뉘어져 있다

1) 로딩
    - 자바 바이트 코드(.class)를 JVM 메소드 영역에 저장
    - 자바 바이트 코드(.class)는 JVM에 의해 메소드 영역에 다음 정보를 저장
        - 로드된 클래스를 비롯한 그의 부모 클래스의 정보
        - 클래스 파일과 Class, Interface, Enum의 관련 여부
        - 변수나 메소드 등의 정보

2) 링크 
    - 링크는 3단계로 나뉘어서 잔행된다
        - 검증 : 읽어 드린 클래스가 자바 언어 명세 및 JVM 명세에 명시된 대로 잘 구성되었는지 검사
        - 준비 : 클래스가 필요로 하는 메모리를 할당하고 클래스에 정의된 필드, 메소드, 인터페이스를 나타내는 데이터 구조를 준비
        - 분석 : 심볼릭 레퍼런스를 메소드 영역에 있는 실제 레퍼런스로 교체
            > 심볼릭 레퍼런스란? <br>
                특정 자원을 참조하는 고수준의 이름, 문자열, 식별자로 JVM이 클래스 파일을 해석하는 과정에서 사용된다 <br> 
                컴파일 시점에 결졍되며 런타임 시점에 실제 메모리 주소로 변환된다 <br>
                종류로는 클래스, 메소드, 필드 3가지로 존재한다 <br>
                ex) java.util.ArrayList -> 클래스 심볼릭 레퍼런스

3) 초기화
    - 클래스 변수들을 적절한 값으로 초기화 한다(static 필드들이 설정된 값으로 초기화)

### 클래스 로더 종류
1. 부트스트랩 클래스 로더 (Bootstrap Class Loader)
- JVM 시작 시 가장 최초로 실행되는 클래스 로더이다 
- 부트스트랩 클래스 로더는 자바 클래스(.class 파일)를 로드하는 것이 아닌, 자바 클래스를 로드할 수 있는 자바 자체의 클래스 로더와 최소한의 자바 클래스(java.lang.Object, Class, ClassLoader)만을 로드한다
    - Java 8 
        - jre/lib/rt.jar 및 기타 핵심 라이브러리와 같은 JDK의 내부 클래스를 로드
        - 단일 jar 파일에서 모든 라이브러리 클래스를 로드하여 클래스 로딩 구조는 간단했지만 사용하지 않는 클래스들도 같이 로드됨
        > rt.jar란? <br>
        java에서 기본적으로 제공하는 핵심 클래스들이 들어가 있는 jar파일(InputStream, Map 등등)
    - Java 9 이후 
        -  java 9에서 도입된 모듈 시스템을 사용하여 rt.jar을 제거하고 /lib 내에 모듈화되어 포함 <br>
        ex) java.base, java.xml, java.sql로 각각 모듈화됨
        - java.base모듈은 java의 핵심 클래스를 담고 있으며, 모든 java 프로그램에서 자동으로 로드되므로 별도로 명시하지 않아도 됨
        - java.base 모듈을 제외한 다른 모듈들은 명시적으로 선언하지 않으면 기본적으로 로드되지 않고 사용할 때 로드됨

2. 확장 클래스 로더 (Extension Class Loader)
- 확장 클래스 로더는 부트스트랩 클래스 로더를 부모로 갖는 클래스 로더로서, 확장 자바 클래스들을 로드한다
- java.ext.dirs 환경 변수에 설정된 디렉토리의 클래스 파일을 로드하고, 이 값이 설정되어 있지 않은 경우 ${JAVA_HOME}/jre/lib/ext 에 있는 클래스 파일을 로드한다 
    - Java 8
        - URLClassLoader를 상속하며, jre/lib/ext 내 모든 클래스를 로드
        - RLClassLoader는 지정된 URL 경로(주로 JAR 파일 위치)에서 클래스 파일을 읽고 로드할 수 있는 클래스 로더
    - Java 9 이후
        - 모듈 시스템 도입으로 jre/lib/ext가 모듈 시스템을 통해 필요한 모듈을 명시적으로 관리하고 로드
        - Java 9에서는 확장 클래스 로더가 Platform Loader로 이름이 변경
        - Platform Loader는 이제 URLClassLoader 대신 BuiltinClassLoader를 상속하여, 더 이상 URL을 통한 클래스 로딩이 아니라 모듈 시스템을 통해 클래스를 로딩

    > 확장 라이브러리란? <br>
    Java의 표준 라이브러리(java.base 모듈에 포함된 핵심 클래스) 외에, 특정 기능을 추가로 제공하는 라이브러리를 의미<br>
    JDBC 드라이버, 암호화 라이브러리 등등

3. 시스템 클래스 로더 (System Class Loader)
- 자바 프로그램 실행 시 지정한 Classpath에 있는 클래스 파일 혹은 jar에 속한 클래스들을 로드한다
- 쉽게 말하자면, 우리가 만든 .class 확장자 파일을 로드한다

### 클래스 로더의 동작 방식
- 클래스 로더는 새로운 클래스를 로드해야 할 때, 다음과 같은 방식으로 로드를 수행한다

1. JVM의 메소드 영역에 클래스가 로드되어 있는지 확인한다 만일 로드되어 있는 경우 해당 클래스를 사용한다

2. 메소드 영역에 클래스가 로드되어 있지 않을 경우, 시스템 클래스 로더에 클래스 로드를 요청한다

3. 시스템 클래스 로더는 확장 클래스 로더에 요청을 위임한다

4. 확장 클래스 로더는 부트스트랩 클래스 로더에 요청을 위임한다

5. 부트스트랩 클래스 로더는 부트스트랩 Classpath(JDK/JRE/LIB)에 해당 클래스가 있는지 확인한다

6. 클래스가 존재하지 않는 경우 확장 클래스 로더에게 요청을 넘긴다

7. 확장 클래스 로더는 확장 Classpath(JDK/JRE/LIB/EXT)에 해당 클래스가 있는지 확인한다 <br> 클래스가 존재하지 않을 경우 시스템 클래스 로더에게 요청을 넘긴다

8. 시스템 클래스 로더는 시스템 Classpath에 해당 클래스가 있는지 확인한다<br> 클래스가 존재하지 않는 경우 ClassNotFoundException을 발생시킨다

### 클래스 로더가 지켜야 할 세 가지 원칙
1. 위임 원칙
    - 클래스 로더는 클래스 또는 리소스를 찾기 위해 요청을 받았을 때, 상위 클래스 로더에게 책임을 위임하는 위임 모델을 따른다 
    - 위에서 설명한 클래스 로더 동작 방식을 보면, 위임 법칙을 따른다는 것을 확인할 수 있다

2. 가시 범위 원칙
    - 하위 클래스 로더는 상위 클래스 로더가 로드한 클래스를 볼 수 있지만, 반대로 상위 클래스 로더는 하위 클래스 로더가 로드한 클래스를 알 수 없다
    - 이로 인해 java.lang.Object 클래스 등 상위 클래스 로더에서 로드한 클래스도 하위 클래스 로더인 시스템 클래스 로더 등에서 사용할 수 있다

3. 유일성의 원칙
    - 하위 클래스 로더가 상위 클래스 로더에게 로드한 클래스를 다시 로드하지 않아야 한다는 원칙이다
    - 위임 원칙에 의해서 위쪽으로 책임을 위임하기 때문에 고유한 클래스를 보장할 수 있다
