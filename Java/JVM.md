## JVM(Java Virtual Machine)이란?
- JVM은 OS에 종속받지 않고 CPU 가 Java를 인식, 실행할 수 있게 하는 가상 컴퓨터로 시스템 메모리를 관리하면서, 자바 기반 애플리케이션을 위해 이식 가능한 실행 환경을 제공

### Java Compile과정
1. 개발자가 java 코드를 작성
2. build 진행
3. java compiler를 통해 javac 명령어를 통해 바이트코드(.class) 코드가 생성
4. Class Loader를 통해 JVM 메모리 내로 로드
5. Execution Engine(실행엔진)을 통해 컴퓨터가 읽을 수 있는 기계어로 해석되어 실행

### JVM 동작방식
<img width="807" alt="스크린샷 2023-12-11 오후 8 03 26" src="https://github.com/juhwan-Ki/TIL/assets/87765888/f032dff8-70dd-4ac5-bf57-374e6cf7ead0">

1. Java program을 시작시키면 JVM은 OS로부터 메모리를 할당받는다.
2. Java Compiler가 자바 소스코드(.java)코드를 컴파일 하여 바이트 코드(.class)로 컴파일한다.
3. JVM에 Class Loader는 동적 로딩을 통해 필요한 클래스들을 로딩 및 링크 하여 Runtime Data Area(실질적인 메모리를 할당 받아 관리하는 영역)에 올린다.
4. Runtime Data Area에 로딩 된 바이트 코드는 Execution Engine을 통해 해석된다.
5. 이 과정에서 Execution Engine에 의해 Garbage Collector의 작동과 Thread 동기화가 이루어진다.

### JVM 구조

<img width="729" alt="스크린샷 2023-12-11 오후 8 03 42" src="https://github.com/juhwan-Ki/TIL/assets/87765888/a7571a44-2578-493b-882e-9d68de1e2d9e">

### 1. 클래스 로더(Class Loader)
- 클래스 로더는 JVM 내로 클래스 파일(*.class)을 동적으로 로드하고, 링크를 통해 배치하는 작업을 수행하는 모듈로 로드된 바이트 코드(.class)들을 엮어서 JVM의 메모리 영역인 Runtime Data Areas에 배치한다.

- 클래스를 메모리에 올리는 로딩 기능은 한번에 메모리에 올리지 않고, 어플리케이션에서 필요한 경우 동적으로 메모리에 적재하게 된다.

1. Loading(로드) : 클래스 파일을 가져와서 JVM의 메모리에 로드
2. Linking(링크) : 클래스 파일을 사용하기 위해 검증하는 과정
- Verifying(검증) : 읽어들인 클래스가 JVM 명세에 명시된 대로 구성되어 있는지 검사
- preparing(준비) : 클래스가 필요로 하는 메모리를 할당
- Resolving(분석) : 클래스의 상수 풀 내 모든 심볼릭 레퍼런스를 다이렉트 레퍼런스로 변경

3. Initialization(초기화) : 클래스 변수들을 적절한 값으로 초기화 
<br>(static 필드들을 설정된 값으로 초기화 등)

### 2. 실행 엔진(Execution Engine)
- 실행 엔진은 클래스 로더를 통해 런타임 데이터 영역에 배치된 바이트 코드를 명령어 단위로 읽어서 실행한다.
- 바이트 코드는 기계가 바로 실행할 수 있는 기계어가 아니기 때문에 실행 엔진을 통해 기계어로 변환해준다.<br>
이때 인터프리터와 JIT를 사용하여 변환한다.

- 인터프리터(Interpreter) 
    - 바이트 코드 명령어를 하나씩 읽어서 해석하고 바로 실행한다. JVM안에서 바이트코드는 기본적으로 인터프리터 방식으로 동작한다. 다만 같은 메소드 라도 여러번 호출이 된다면 매번 해석하고 수행해야 되서 전체적인 속도는 느리다.
- JIT 컴파일러(Just-in-Time)
    - 인터프리터의 단점을 보완하기 위해 도입된 방식으로 반복되는 코드를 파악하여 바이트 코드 전체를 컴파일하여 **네이티브 코드(JAVA에서 부모가 되는 C언어나, C++, 어셈블리어로 구성된 코드)** 로 변환하여 캐싱 하였다가 사용하는 방식이다.
    - 하나씩 인터프리팅하여 실행하는것이 아니라, 컴파일된 네이티브 코드를 실행하는 것이기 때문에 전체적인 실행 속도는 인터프리팅 방식보다 빠르다.
    - 하지만 바이트 코드를 네이티브 코드로 변환하는 것에 비용이 소모되기 때문에 모든 코드를 JIT 방식으로 사용하지 않고 일정 기준이 넘어가면 JIT를 사용한다.
- GC(Garbage Collection)
    - 더 이상 참조되지 않는 Garbage(가비지)라고 불리는 불필요한 메모리를 알아서 정리해주는 역할

### 3. 런타임 데이터 영역 (Runtime Data Area)
- JVM의 메모리 영역으로 자바 애플리케이션을 실행할 때 사용되는 데이터들을 적재하는 영역이다.
- Method Area, Heap Area 는 모든 쓰레드(Thread)가 공유하는 영역이고, 나머지 Stack Area, PC Register, Native Method Stack 은 각 쓰레드 마다 생성되는 개별 영역이다.

- Method Area(Static Area)
    -  JVM이 시작될 때 생성되는 공간으로 바이트 코드(.class)를 처음 메모리 공간에 올릴 때 초기화되는 대상을 저장하기 위한 메모리 공간이다. JVM이 동작하고 클래스가 로드될 때 적재되서 프로그램이 종료될 때까지 저장 된다.
    - 정적 필드와 클래스 구조만 저장된다.
- Heap Area
    - JVM이 관리하는 프로그램 상에서 데이터를 저장하기 위해 런타임 시 동적으로 할당하여 사용하는 영역으로 new 연산자르 사용하여 생성되는 클래스의 인스턴스 변수, 배열 등 참조타입이 저장되는 영역이다.
    - 변수의 실제 값은 Heap에 저장이 되고 Stack에서 Heap 영역의 참조값을 가져 참조값을 통해 Heap 영역에 있는 변수를 컨트롤한다.
    - 참조하는 변수나 필드가 없다면 사용하지 않는 객체가 되어 GC(Garbage Collector)에 의해 자동으로 제거된다.
- PC Register
    - PC 레지스터는 쓰레드가 시작될 때 생성되며, 현재 수행중인 JVM 명령어 주소를 저장하는 공간이다.
- Stack Area
    - 메소드 내에서 정의하는 기본자료형(원시자료형 int, double 등)에 해당되는 지역변수의 데이터의 값이 저장되는 공간으로 해당 메소드가 호출되고 할당이 종료되면 메모리가 해제된다. (원시타입은 변수명과 값이 같이 Stack에 저장된다). Stack 영역의 메모리는 Thread 하나당 하나씩 할당되며, LIFO(Last In First Out)의 구조를 갖는다.
- Native Method Stack
    - 자바 코드가 컴파일되어 생성되는 바이트 코드가 아닌 실제 실행할 수 있는 기계어로 작성된 프로그램을 실행시키는 영역
    - 자바 이외의 언어(C, C++, 어셈블리 등)로 작성된 네이티브 코드를 실행하기 위한 공간으로 JIT 컴파일러로 캐싱해 놓은 코드가 실행될 때 이 공간을 사용한다.